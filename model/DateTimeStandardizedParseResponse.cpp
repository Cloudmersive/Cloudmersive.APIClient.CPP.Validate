/**
 * validateapi
 * The validation APIs help you validate data. Check if an E-mail address is real. Check if a domain is real. Check up on an IP address, and even where it is located. All this and much more is available in the validation API.
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.11.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "DateTimeStandardizedParseResponse.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

DateTimeStandardizedParseResponse::DateTimeStandardizedParseResponse()
{
    m_Successful = false;
    m_SuccessfulIsSet = false;
    m_ParsedDateResult = utility::datetime();
    m_ParsedDateResultIsSet = false;
    m_Year = 0;
    m_YearIsSet = false;
    m_Month = 0;
    m_MonthIsSet = false;
    m_Day = 0;
    m_DayIsSet = false;
    m_Hour = 0;
    m_HourIsSet = false;
    m_Minute = 0;
    m_MinuteIsSet = false;
    m_Second = 0;
    m_SecondIsSet = false;
    m_DayOfWeek = utility::conversions::to_string_t("");
    m_DayOfWeekIsSet = false;
}

DateTimeStandardizedParseResponse::~DateTimeStandardizedParseResponse()
{
}

void DateTimeStandardizedParseResponse::validate()
{
    // TODO: implement validation
}

web::json::value DateTimeStandardizedParseResponse::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_SuccessfulIsSet)
    {
        val[utility::conversions::to_string_t("Successful")] = ModelBase::toJson(m_Successful);
    }
    if(m_ParsedDateResultIsSet)
    {
        val[utility::conversions::to_string_t("ParsedDateResult")] = ModelBase::toJson(m_ParsedDateResult);
    }
    if(m_YearIsSet)
    {
        val[utility::conversions::to_string_t("Year")] = ModelBase::toJson(m_Year);
    }
    if(m_MonthIsSet)
    {
        val[utility::conversions::to_string_t("Month")] = ModelBase::toJson(m_Month);
    }
    if(m_DayIsSet)
    {
        val[utility::conversions::to_string_t("Day")] = ModelBase::toJson(m_Day);
    }
    if(m_HourIsSet)
    {
        val[utility::conversions::to_string_t("Hour")] = ModelBase::toJson(m_Hour);
    }
    if(m_MinuteIsSet)
    {
        val[utility::conversions::to_string_t("Minute")] = ModelBase::toJson(m_Minute);
    }
    if(m_SecondIsSet)
    {
        val[utility::conversions::to_string_t("Second")] = ModelBase::toJson(m_Second);
    }
    if(m_DayOfWeekIsSet)
    {
        val[utility::conversions::to_string_t("DayOfWeek")] = ModelBase::toJson(m_DayOfWeek);
    }

    return val;
}

void DateTimeStandardizedParseResponse::fromJson(web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("Successful")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Successful")];
        if(!fieldValue.is_null())
        {
            setSuccessful(ModelBase::boolFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("ParsedDateResult")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("ParsedDateResult")];
        if(!fieldValue.is_null())
        {
            setParsedDateResult(ModelBase::dateFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Year")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Year")];
        if(!fieldValue.is_null())
        {
            setYear(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Month")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Month")];
        if(!fieldValue.is_null())
        {
            setMonth(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Day")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Day")];
        if(!fieldValue.is_null())
        {
            setDay(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Hour")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Hour")];
        if(!fieldValue.is_null())
        {
            setHour(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Minute")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Minute")];
        if(!fieldValue.is_null())
        {
            setMinute(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("Second")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("Second")];
        if(!fieldValue.is_null())
        {
            setSecond(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("DayOfWeek")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("DayOfWeek")];
        if(!fieldValue.is_null())
        {
            setDayOfWeek(ModelBase::stringFromJson(fieldValue));
        }
    }
}

void DateTimeStandardizedParseResponse::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_SuccessfulIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Successful"), m_Successful));
    }
    if(m_ParsedDateResultIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("ParsedDateResult"), m_ParsedDateResult));
        
    }
    if(m_YearIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Year"), m_Year));
    }
    if(m_MonthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Month"), m_Month));
    }
    if(m_DayIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Day"), m_Day));
    }
    if(m_HourIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Hour"), m_Hour));
    }
    if(m_MinuteIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Minute"), m_Minute));
    }
    if(m_SecondIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("Second"), m_Second));
    }
    if(m_DayOfWeekIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("DayOfWeek"), m_DayOfWeek));
        
    }
}

void DateTimeStandardizedParseResponse::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("Successful")))
    {
        setSuccessful(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Successful"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("ParsedDateResult")))
    {
        setParsedDateResult(ModelBase::dateFromHttpContent(multipart->getContent(utility::conversions::to_string_t("ParsedDateResult"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Year")))
    {
        setYear(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Year"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Month")))
    {
        setMonth(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Month"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Day")))
    {
        setDay(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Day"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Hour")))
    {
        setHour(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Hour"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Minute")))
    {
        setMinute(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Minute"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("Second")))
    {
        setSecond(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("Second"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("DayOfWeek")))
    {
        setDayOfWeek(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("DayOfWeek"))));
    }
}

bool DateTimeStandardizedParseResponse::isSuccessful() const
{
    return m_Successful;
}


void DateTimeStandardizedParseResponse::setSuccessful(bool value)
{
    m_Successful = value;
    m_SuccessfulIsSet = true;
}
bool DateTimeStandardizedParseResponse::successfulIsSet() const
{
    return m_SuccessfulIsSet;
}

void DateTimeStandardizedParseResponse::unsetSuccessful()
{
    m_SuccessfulIsSet = false;
}

utility::datetime DateTimeStandardizedParseResponse::getParsedDateResult() const
{
    return m_ParsedDateResult;
}


void DateTimeStandardizedParseResponse::setParsedDateResult(utility::datetime value)
{
    m_ParsedDateResult = value;
    m_ParsedDateResultIsSet = true;
}
bool DateTimeStandardizedParseResponse::parsedDateResultIsSet() const
{
    return m_ParsedDateResultIsSet;
}

void DateTimeStandardizedParseResponse::unsetParsedDateResult()
{
    m_ParsedDateResultIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getYear() const
{
    return m_Year;
}


void DateTimeStandardizedParseResponse::setYear(int32_t value)
{
    m_Year = value;
    m_YearIsSet = true;
}
bool DateTimeStandardizedParseResponse::yearIsSet() const
{
    return m_YearIsSet;
}

void DateTimeStandardizedParseResponse::unsetYear()
{
    m_YearIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getMonth() const
{
    return m_Month;
}


void DateTimeStandardizedParseResponse::setMonth(int32_t value)
{
    m_Month = value;
    m_MonthIsSet = true;
}
bool DateTimeStandardizedParseResponse::monthIsSet() const
{
    return m_MonthIsSet;
}

void DateTimeStandardizedParseResponse::unsetMonth()
{
    m_MonthIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getDay() const
{
    return m_Day;
}


void DateTimeStandardizedParseResponse::setDay(int32_t value)
{
    m_Day = value;
    m_DayIsSet = true;
}
bool DateTimeStandardizedParseResponse::dayIsSet() const
{
    return m_DayIsSet;
}

void DateTimeStandardizedParseResponse::unsetDay()
{
    m_DayIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getHour() const
{
    return m_Hour;
}


void DateTimeStandardizedParseResponse::setHour(int32_t value)
{
    m_Hour = value;
    m_HourIsSet = true;
}
bool DateTimeStandardizedParseResponse::hourIsSet() const
{
    return m_HourIsSet;
}

void DateTimeStandardizedParseResponse::unsetHour()
{
    m_HourIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getMinute() const
{
    return m_Minute;
}


void DateTimeStandardizedParseResponse::setMinute(int32_t value)
{
    m_Minute = value;
    m_MinuteIsSet = true;
}
bool DateTimeStandardizedParseResponse::minuteIsSet() const
{
    return m_MinuteIsSet;
}

void DateTimeStandardizedParseResponse::unsetMinute()
{
    m_MinuteIsSet = false;
}

int32_t DateTimeStandardizedParseResponse::getSecond() const
{
    return m_Second;
}


void DateTimeStandardizedParseResponse::setSecond(int32_t value)
{
    m_Second = value;
    m_SecondIsSet = true;
}
bool DateTimeStandardizedParseResponse::secondIsSet() const
{
    return m_SecondIsSet;
}

void DateTimeStandardizedParseResponse::unsetSecond()
{
    m_SecondIsSet = false;
}

utility::string_t DateTimeStandardizedParseResponse::getDayOfWeek() const
{
    return m_DayOfWeek;
}


void DateTimeStandardizedParseResponse::setDayOfWeek(utility::string_t value)
{
    m_DayOfWeek = value;
    m_DayOfWeekIsSet = true;
}
bool DateTimeStandardizedParseResponse::dayOfWeekIsSet() const
{
    return m_DayOfWeekIsSet;
}

void DateTimeStandardizedParseResponse::unsetDayOfWeek()
{
    m_DayOfWeekIsSet = false;
}

}
}
}
}

